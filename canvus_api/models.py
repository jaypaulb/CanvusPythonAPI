"""
Pydantic models for request and response data validation.
"""

from typing import Optional, List, Dict, Any
from datetime import datetime
from pydantic import BaseModel, Field


class ServerStatus(BaseModel):
    """Server status information."""
    version: str
    status: str
    uptime: float
    active_connections: int
    memory_usage: float = Field(description="Memory usage in MB")


class ServerInfo(BaseModel):
    """Server information from /server-info endpoint."""
    version: str
    api: List[str] = Field(description="List of supported API versions")
    server_id: str
    go: str = Field(description="Go version used by the server")


class ServerConfig(BaseModel):
    """Server configuration from /server-config endpoint."""
    server_name: Optional[str] = None
    features: Optional[Dict[str, Any]] = Field(default_factory=dict)
    auth: Optional[Dict[str, Any]] = Field(default_factory=dict)
    access: Optional[str] = None
    external_url: Optional[str] = None
    email: Optional[Dict[str, Any]] = Field(default_factory=dict)
    authentication: Optional[Dict[str, Any]] = Field(default_factory=dict)

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class CanvasStatus(BaseModel):
    """Status information for a specific canvas."""
    id: str
    name: str
    active: bool
    connected_users: int
    size: Dict[str, int] = Field(
        description="Canvas dimensions",
        example={"width": 1920, "height": 1080}
    )


class User(BaseModel):
    """User information from the API.
    
    Note:
        Only email, name, password, admin, approved, and blocked can be set during creation.
        Other fields are managed by the server.
    """
    # Required fields for user creation
    email: str
    name: str
    
    # Optional fields we can set
    password: Optional[str] = None
    admin: bool = False
    approved: bool = True
    blocked: bool = False
    
    # Server-managed fields (should not be validated during creation)
    id: Optional[int] = None
    created_at: Optional[str] = None  # Accept any string format from server
    last_login: Optional[str] = None  # Accept any string format from server
    state: Optional[str] = None


class Canvas(BaseModel):
    """Canvas information from the API."""
    id: str
    name: str
    access: str
    asset_size: int
    folder_id: str
    in_trash: bool
    mode: str = Field(description="'demo' or 'normal'")
    preview_hash: Optional[str] = None
    state: str
    description: Optional[str] = None
    link_permission: Optional[str] = None
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None


class CanvasFolder(BaseModel):
    """Canvas folder object."""
    id: str
    name: str
    folder_id: str
    access: str
    in_trash: bool
    state: str


class BaseWidget(BaseModel):
    """Base class for all canvas widgets.
    
    Note:
        - `id` is a UUID v4 generated by the server and cannot be set by the client
        - `state` is managed by the server to track widget lifecycle (e.g., changes to "deleted" on successful deletion)
    """
    id: str  # Server-generated UUID v4
    state: str  # Server-managed state
    widget_type: str  # Type of widget
    depth: int = 0
    location: Dict[str, float]  # {"x": float, "y": float}
    scale: float = 1.0
    size: Dict[str, float]  # {"width": float, "height": float}
    pinned: bool = False
    parent_id: Optional[str] = None
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None


class Note(BaseWidget):
    """A text note in a canvas."""
    widget_type: str = "Note"
    state: str = "normal"  # Server-managed, defaults to "normal"
    text: str
    title: Optional[str] = None
    text_color: str = "#000000ff"
    background_color: str = "#ffffffff"
    auto_text_color: bool = True


class Image(BaseWidget):
    """Image in a canvas.
    
    Note:
        - `hash` is server-generated for each uploaded file and cannot be modified by the client
        - When creating a new image, you can reference an existing file by providing its hash
    """
    widget_type: str = "Image"
    hash: str  # Server-generated file identifier
    original_filename: Optional[str] = None
    title: Optional[str] = None


class Browser(BaseWidget):
    """A web browser instance in a canvas."""
    widget_type: str = "Browser"
    state: str = "normal"  # Server-managed, defaults to "normal"
    url: str
    title: Optional[str] = None
    main_frame_scroll_offset: Dict[str, int] = Field(
        default_factory=lambda: {"x": 0, "y": 0}
    )
    transparent_mode: bool = False


class Video(BaseWidget):
    """Video in a canvas.
    
    Note:
        - `hash` is server-generated for each uploaded file and cannot be modified by the client
        - When creating a new video, you can reference an existing file by providing its hash
    """
    widget_type: str = "Video"
    hash: str  # Server-generated file identifier
    original_filename: Optional[str] = None
    title: Optional[str] = None
    playback_position: float = 0
    playback_state: str = "STOPPED"  # "STOPPED", "PLAYING", etc.


class PDF(BaseWidget):
    """PDF document in a canvas.
    
    Note:
        - `hash` is server-generated for each uploaded file and cannot be modified by the client
        - When creating a new PDF, you can reference an existing file by providing its hash
    """
    widget_type: str = "Pdf"  # Note: Capital P in Pdf
    hash: str  # Server-generated file identifier
    original_filename: Optional[str] = None
    title: Optional[str] = None
    index: int = 0  # Current page being displayed


class Widget(BaseWidget):
    """Generic widget in a canvas. Used for custom widget types."""
    widget_type: str = Field(description="Custom widget type")
    state: str = "normal"  # Server-managed, defaults to "normal"
    config: Dict[str, Any] = Field(default_factory=dict)
    
    @classmethod
    def model_validate(cls, obj: Any) -> 'Widget':
        """Custom validation to handle CanvasBackground."""
        if isinstance(obj, dict) and obj.get("widget_type") == "CanvasBackground":
            # For CanvasBackground, use default location and size
            obj.setdefault("location", {"x": 0, "y": 0})
            obj.setdefault("size", {"width": 1920, "height": 1080})
            obj.setdefault("id", "background")
        return super().model_validate(obj)


class Anchor(BaseWidget):
    """An anchor point in a canvas.
    
    Anchors are used to define regions or points of interest in a canvas.
    They can be used for navigation and organization of content.
    """
    widget_type: str = "Anchor"
    state: str = "normal"  # Server-managed, defaults to "normal"
    anchor_index: int = 0
    anchor_name: str = "New anchor"


class ConnectorEndpoint(BaseModel):
    """Represents one end of a connector (source or destination)."""
    auto_location: bool = False
    id: str
    rel_location: Dict[str, float]  # {"x": float, "y": float}
    tip: str  # "none" or "solid-equilateral-triangle"


class Connector(BaseModel):
    """A connector between two widgets in a canvas.
    
    Connectors create visual connections between widgets with customizable
    appearance including line style, color, width and arrow tips.
    """
    id: str
    widget_type: str = "Connector"
    state: str = "normal"  # Server-managed, defaults to "normal"
    src: ConnectorEndpoint
    dst: ConnectorEndpoint
    line_color: str = "#e7e7f2ff"
    line_width: float = 5.0
    type: str = "curve"  # Currently only "curve" supported in Canvus 3.2


class AccessToken(BaseModel):
    """Access token information."""
    id: str
    description: str
    created_at: datetime
    plain_token: Optional[str] = None  # Only present in create response


class TokenResponse(BaseModel):
    """Response from token creation."""
    id: str
    description: str
    created_at: datetime
    plain_token: str  # The actual token value, only available on creation


class ViewRectangle(BaseModel):
    """View rectangle in canvas coordinates."""
    x: float
    y: float
    width: float
    height: float


class CanvasSize(BaseModel):
    """Canvas dimensions."""
    width: float
    height: float


class WorkspaceSize(BaseModel):
    """Workspace window dimensions."""
    width: int
    height: int


class Location(BaseModel):
    """2D location coordinates."""
    x: float
    y: float


class Workspace(BaseModel):
    """Workspace information from the API."""
    canvas_id: str = ""
    canvas_size: Optional[CanvasSize] = None
    index: int
    info_panel_visible: bool = True
    location: Location
    pinned: bool = False
    server_id: str = ""
    size: WorkspaceSize
    state: str = "normal"
    user: str = ""
    view_rectangle: ViewRectangle
    workspace_name: str
    workspace_state: str  # "open" or "canvas_list"