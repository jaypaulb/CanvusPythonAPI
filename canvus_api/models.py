"""
Pydantic models for request and response data validation.
"""

from typing import Optional, List, Dict, Any
from datetime import datetime
from pydantic import BaseModel, Field


class ServerStatus(BaseModel):
    """Server status information."""

    version: str
    status: str
    uptime: float
    active_connections: int
    memory_usage: float = Field(description="Memory usage in MB")


class ServerInfo(BaseModel):
    """Server information from /server-info endpoint."""

    version: str
    api: List[str] = Field(description="List of supported API versions")
    server_id: str
    go: str = Field(description="Go version used by the server")


class ServerConfig(BaseModel):
    """Server configuration from /server-config endpoint."""

    server_name: Optional[str] = None
    features: Optional[Dict[str, Any]] = Field(default_factory=dict)
    auth: Optional[Dict[str, Any]] = Field(default_factory=dict)
    access: Optional[str] = None
    external_url: Optional[str] = None
    email: Optional[Dict[str, Any]] = Field(default_factory=dict)
    authentication: Optional[Dict[str, Any]] = Field(default_factory=dict)

    class Config:
        json_encoders = {datetime: lambda v: v.isoformat()}


class CanvasStatus(BaseModel):
    """Status information for a specific canvas."""

    id: str
    name: str
    active: bool
    connected_users: int
    size: Dict[str, int] = Field(
        description="Canvas dimensions", examples=[{"width": 1920, "height": 1080}]
    )


class User(BaseModel):
    """User information from the API.

    Note:
        Only email, name, password, admin, approved, and blocked can be set during creation.
        Other fields are managed by the server.
    """

    # Required fields for user creation
    email: str
    name: str

    # Optional fields we can set
    password: Optional[str] = None
    admin: bool = False
    approved: bool = True
    blocked: bool = False

    # Server-managed fields (should not be validated during creation)
    id: Optional[int] = None
    created_at: Optional[str] = None  # Accept any string format from server
    last_login: Optional[str] = None  # Accept any string format from server
    state: Optional[str] = None


class Canvas(BaseModel):
    """Canvas information from the API."""

    id: str
    name: str
    access: str
    asset_size: int
    folder_id: str
    in_trash: bool
    mode: str = Field(description="'demo' or 'normal'")
    preview_hash: Optional[str] = None
    state: str
    description: Optional[str] = None
    link_permission: Optional[str] = None
    owner_id: Optional[int] = None
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None


class CanvasFolder(BaseModel):
    """Canvas folder object."""

    id: str
    name: str
    folder_id: str
    access: str
    in_trash: bool
    state: str


class BaseWidget(BaseModel):
    """Base class for all canvas widgets.

    Note:
        - `id` is a UUID v4 generated by the server and cannot be set by the client
        - `state` is managed by the server to track widget lifecycle (e.g., changes to "deleted" on successful deletion)
    """

    id: str  # Server-generated UUID v4
    state: str  # Server-managed state
    widget_type: str  # Type of widget
    depth: float = 0.0  # Changed from int to float to handle fractional values
    location: Dict[str, float]  # {"x": float, "y": float}
    scale: float = 1.0
    size: Dict[str, float]  # {"width": float, "height": float}
    pinned: bool = False
    parent_id: Optional[str] = None
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None


class Note(BaseWidget):
    """A text note in a canvas."""

    widget_type: str = "Note"
    state: str = "normal"  # Server-managed, defaults to "normal"
    text: str
    title: Optional[str] = None
    text_color: str = "#000000ff"
    background_color: str = "#ffffffff"
    auto_text_color: bool = True


class Image(BaseWidget):
    """Image in a canvas.

    Note:
        - `hash` is server-generated for each uploaded file and cannot be modified by the client
        - When creating a new image, you can reference an existing file by providing its hash
    """

    widget_type: str = "Image"
    hash: str  # Server-generated file identifier
    original_filename: Optional[str] = None
    title: Optional[str] = None


class Browser(BaseWidget):
    """A web browser instance in a canvas."""

    widget_type: str = "Browser"
    state: str = "normal"  # Server-managed, defaults to "normal"
    url: str
    title: Optional[str] = None
    main_frame_scroll_offset: Dict[str, int] = Field(
        default_factory=lambda: {"x": 0, "y": 0}
    )
    transparent_mode: bool = False


class Video(BaseWidget):
    """Video in a canvas.

    Note:
        - `hash` is server-generated for each uploaded file and cannot be modified by the client
        - When creating a new video, you can reference an existing file by providing its hash
    """

    widget_type: str = "Video"
    hash: str  # Server-generated file identifier
    original_filename: Optional[str] = None
    title: Optional[str] = None
    playback_position: float = 0
    playback_state: str = "STOPPED"  # "STOPPED", "PLAYING", etc.


class PDF(BaseWidget):
    """PDF document in a canvas.

    Note:
        - `hash` is server-generated for each uploaded file and cannot be modified by the client
        - When creating a new PDF, you can reference an existing file by providing its hash
    """

    widget_type: str = "Pdf"  # Note: Capital P in Pdf
    hash: str  # Server-generated file identifier
    original_filename: Optional[str] = None
    title: Optional[str] = None
    index: int = 0  # Current page being displayed


class Widget(BaseWidget):
    """Generic widget in a canvas. Used for custom widget types."""

    widget_type: str = Field(description="Custom widget type")
    state: str = "normal"  # Server-managed, defaults to "normal"
    config: Dict[str, Any] = Field(default_factory=dict)

    @classmethod
    def model_validate(
        cls,
        obj: Any,
        *,
        strict: bool | None = None,
        from_attributes: bool | None = None,
        context: Any = None,
        by_alias: bool | None = None,
        by_name: bool | None = None,
    ) -> "Widget":
        """Custom validation to handle CanvasBackground."""
        if isinstance(obj, dict) and obj.get("widget_type") == "CanvasBackground":
            # For CanvasBackground, use default location and size
            obj.setdefault("location", {"x": 0, "y": 0})
            obj.setdefault("size", {"width": 1920, "height": 1080})
            obj.setdefault("id", "background")
        return super().model_validate(
            obj, strict=strict, from_attributes=from_attributes, context=context
        )


class Anchor(BaseWidget):
    """An anchor point in a canvas.

    Anchors are used to define regions or points of interest in a canvas.
    They can be used for navigation and organization of content.
    """

    widget_type: str = "Anchor"
    state: str = "normal"  # Server-managed, defaults to "normal"
    anchor_index: int = 0
    anchor_name: str = "New anchor"


class ConnectorEndpoint(BaseModel):
    """Represents one end of a connector (source or destination)."""

    auto_location: bool = False
    id: str
    rel_location: Dict[str, float]  # {"x": float, "y": float}
    tip: str  # "none" or "solid-equilateral-triangle"


class Connector(BaseModel):
    """A connector between two widgets in a canvas.

    Connectors create visual connections between widgets with customizable
    appearance including line style, color, width and arrow tips.
    """

    id: str
    widget_type: str = "Connector"
    state: str = "normal"  # Server-managed, defaults to "normal"
    src: ConnectorEndpoint
    dst: ConnectorEndpoint
    line_color: str = "#e7e7f2ff"
    line_width: float = 5.0
    type: str = "curve"  # Currently only "curve" supported in Canvus 3.2


class AccessToken(BaseModel):
    """Access token information."""

    id: str
    description: str
    created_at: datetime
    plain_token: Optional[str] = None  # Only present in create response


class TokenResponse(BaseModel):
    """Response from token creation."""

    id: str
    description: str
    created_at: datetime
    plain_token: str  # The actual token value, only available on creation


class ViewRectangle(BaseModel):
    """View rectangle in canvas coordinates."""

    x: float
    y: float
    width: float
    height: float


class CanvasSize(BaseModel):
    """Canvas dimensions."""

    width: float
    height: float


class WorkspaceSize(BaseModel):
    """Workspace window dimensions."""

    width: int
    height: int


class Location(BaseModel):
    """2D location coordinates."""

    x: float
    y: float


class Workspace(BaseModel):
    """Workspace information from the API."""

    canvas_id: str = ""
    canvas_size: Optional[CanvasSize] = None
    index: int
    info_panel_visible: bool = True
    location: Location
    pinned: bool = False
    server_id: str = ""
    size: WorkspaceSize
    state: str = "normal"
    user: str = ""
    view_rectangle: ViewRectangle
    workspace_name: str
    workspace_state: str  # "open" or "canvas_list"


class Group(BaseModel):
    """Group information for user management."""

    id: str
    name: str
    description: Optional[str] = None
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None
    member_count: Optional[int] = None


class GroupMember(BaseModel):
    """Group member information."""

    id: str
    name: str
    email: str
    admin: bool = False
    approved: bool = True
    blocked: bool = False
    created_at: Optional[str] = None
    last_login: Optional[str] = None
    state: Optional[str] = None


class VideoInput(BaseModel):
    """Video input widget configuration."""

    id: str
    name: str
    source: str
    location: Dict[str, float]  # {"x": float, "y": float}
    size: Dict[str, float]  # {"width": float, "height": float}
    config: Dict[str, Any] = Field(default_factory=dict)
    depth: float = 1.0  # Changed from int to float to be consistent
    scale: float = 1.0
    pinned: bool = False
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None


class VideoOutput(BaseModel):
    """Video output configuration."""

    id: str
    name: str
    source: Optional[str] = None
    enabled: bool = True
    resolution: Optional[str] = None  # e.g., "1920x1080"
    refresh_rate: Optional[int] = None  # e.g., 60
    config: Dict[str, Any] = Field(default_factory=dict)
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None


class LicenseInfo(BaseModel):
    """License information from the server."""

    license_key: Optional[str] = None
    status: str  # "valid", "expired", "invalid", etc.
    type: Optional[str] = None  # "lifetime", "trial", "subscription", etc.
    edition: Optional[str] = None
    expiry_date: Optional[str] = None
    features: List[str] = Field(default_factory=list)
    max_users: Optional[int] = None
    max_canvases: Optional[int] = None
    has_expired: bool = False
    is_valid: bool = True
    max_clients: Optional[int] = None


class AuditLogEntry(BaseModel):
    """Audit log entry for tracking system events."""

    id: str
    timestamp: datetime
    user_id: Optional[str] = None
    user_email: Optional[str] = None
    action: str
    resource_type: Optional[str] = None
    resource_id: Optional[str] = None
    details: Dict[str, Any] = Field(default_factory=dict)
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None


class MipmapInfo(BaseModel):
    """Mipmap information for image assets."""

    public_hash_hex: str
    canvas_id: str
    levels: List[int] = Field(default_factory=list)
    format: Optional[str] = None
    width: Optional[int] = None
    height: Optional[int] = None
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None


class Annotation(BaseModel):
    """Widget annotation for collaborative features."""

    id: str
    widget_id: str
    type: str  # "comment", "highlight", "drawing", etc.
    content: str
    author_id: Optional[str] = None
    author_name: Optional[str] = None
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None
    position: Optional[Dict[str, float]] = None  # {"x": float, "y": float}
    color: Optional[str] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)


class WidgetZone(BaseModel):
    """A spatial zone for grouping and organizing widgets.
    
    WidgetZones provide a way to define spatial regions in a canvas that can
    be used for organizing widgets, applying operations to groups of widgets,
    and creating spatial relationships between widgets.
    """
    
    id: str
    name: str
    description: Optional[str] = None
    location: Dict[str, float]  # {"x": float, "y": float}
    size: Dict[str, float]  # {"width": float, "height": float}
    color: Optional[str] = None  # Zone border color
    background_color: Optional[str] = None  # Zone background color
    opacity: float = 0.1  # Zone opacity (0.0 to 1.0)
    visible: bool = True
    locked: bool = False  # Whether widgets can be moved in/out of zone
    tolerance: float = 5.0  # Spatial tolerance for zone operations
    created_at: Optional[datetime] = None
    modified_at: Optional[datetime] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)
